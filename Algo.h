#ifndef AlgoH
#define AlgoH

#include <iostream>
//---------------------------------------------------------------------------
/*
Шаблон функции: нахождение максимума из двух значений одного типа.
Аргументы:
константная ссылка x на первое значение,
константная ссылка y на второе значение.
Результат: константная ссылка на максимальное значение.
Требование к типу T:
- должна быть определена операция <
bool operator < (const T &x, const T &y) { ... }
*/
template <class T>
inline const T& Max(const T &x, const T &y)
{
	return x < y ? y : x;
}
//---------------------------------------------------------------------------
/*
Шаблон функции: нахождение минимума из двух значений одного типа.
Аргументы:
константная ссылка x на первое значение,
константная ссылка y на второе значение.
Результат: константная ссылка на минимальное значение.
Требование к типу T: аналогично Max
*/
template <class T>
inline const T& Min(const T &x, const T &y)
{
	return x < y ? x : y;
}
//---------------------------------------------------------------------------
/*
Шаблон функции: копирование массивов равного размера из элементов одинакового типа.
Аргументы:
указатель x на первый элемент результирующего массива,
указатель y на константный объект - адрес первого элемента исходного массива,
count - число элементов в массивах.
Результат: -
Требование к типу T:
- операция присваивания должна быть корректно определена
*/
template <class T>
void Copy(T *x, const T *y, unsigned count)
{
	while (count--)
		*x++ = *y++;
}
//---------------------------------------------------------------------------
/*
Шаблон функции: сравнение массивов равного размера из элементов одинакового типа.
Аргументы:
указатель x на константный объект - адрес первого элемента одного массива,
указатель y на константный объект - адрес первого элемента второго массива,
count - число элементов в массивах.
Результат: true, если массивы равны; false - иначе.
Требование к типу T:
- должна быть определена операция !=
bool operator != (const T &x, const T &y) { ... }
*/
template <class T>
bool Compare(const T *x, const T *y, unsigned count)
{
	while (count--)
		if (*x++ != *y++) return false;
	return true;
}
//---------------------------------------------------------------------------
/*
Шаблон функции: ввод массива из потока.
Аргументы:
указатель x на первый элемент массива,
count - число элементов в массиве,
ссылка на поток ввода stream (по умолчанию стандартный поток ввода cin).
Результат: -
Требование к типу T:
- должна быть определена операция ввода из потока >>
istream& operator >> (istream &stream, T &x) { ... }
*/
//template <class T>
//void Read(T *x, unsigned count, ostream &stream = cin)
//{
//	while (count--)
//		stream >> *x++;
//}
//---------------------------------------------------------------------------
/*
Шаблон функции: вывод массива в поток.
Аргументы:
указатель x на константый объект - адрес первого элемента массива,
count - число элементов в массиве,
ссылка поток вывода stream (по умолчанию стандартный поток вывода cout),
указатель delim на константую строку,
которая выводится после каждого элемента массива (по умолчанию " ").
Результат: -
Требование к типу T:
- должна быть определена операция вывода в поток <<
ostream& operator << (ostream &stream, const T &x) { ... }
*/
static const char *WriteDefDelim = " ";

//template <class T>
//void Write(const T *x, unsigned count, ostream &stream = cout, const char *delim = WriteDefDelim)
//{
//	while (count--)
//		stream << *x++ << delim;
//}
////---------------------------------------------------------------------------
#endif
